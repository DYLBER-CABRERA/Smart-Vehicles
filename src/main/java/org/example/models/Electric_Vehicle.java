package org.example.models;
import org.example.interfaces.Autonomous_Advanced;


public class Electric_Vehicle extends Vehicle implements Autonomous_Advanced {
    private double battery_capacity;
    private double current_charge = 100.0;
    private boolean emergency_mode = false;
    private boolean autopilot_active = false;
    private double energy_consumption_rate = 0.18; // kWh/km promedio
    private int battery_temperature = 25;
    private double kilometers_driven = 0.0;
    private boolean charging = false;
    private double charging_speed = 2.5; // kWh por minuto de carga r√°pida
    private boolean preconditioning = false;
    private boolean engine_running = false;

    public Electric_Vehicle(String id, String brand, String model, int year,
                            int maximum_speed, double battery_capacity) {
        super(id, brand, model, year, maximum_speed);
        this.battery_capacity = battery_capacity;
        this.current_charge = battery_capacity; // Bater√≠a llena inicialmente
    }

    // metodo para cargar la bater√≠a
    public String battery_charging() {
        // Simula carga completa instant√°nea para simplificar
        if (current_charge >= battery_capacity) {
            return "üîã Bater√≠a ya est√° completamente cargada";
        }

        // Iniciar carga
        charging = true;
        // Calcular energ√≠a necesaria para carga completa
        double charge_needed = battery_capacity - current_charge;
        // me dice si la carga actual es igual a la capacidad de la bater√≠a
        current_charge = battery_capacity;
        // Finalizar carga
        charging = false;

        // Precondicionamiento autom√°tico despu√©s de carga completa
        preconditioning = true;
        // temperatura de la bateria
        battery_temperature = 30;

        return String.format("‚ö° CARGA COMPLETADA ‚ö°\n" +
                        "Veh√≠culo: %s %s\n" +
                        "Energ√≠a agregada: %.2f kWh\n" +
                        "Capacidad total: %.1f kWh\n" +
                        "Nivel actual: 100%%\n" +
                        "Autonom√≠a estimada: %.0f km\n" +
                        "üå°Ô∏è Bater√≠a preacondicionada para √≥ptimo rendimiento",
                getBrand(), getModel(), charge_needed, battery_capacity,
                current_charge / energy_consumption_rate);
    }

    // M√©todos para encender y apagar el motor
    public String startEngine() {
        //si el nivel de combustible es 0, no se puede encender
        if (engine_running) {
            return "‚ö†Ô∏è El motor ya est√° apagado.";
        }
        else if (current_charge <= 0) {
            return "üîã Bater√≠a agotada. No se puede encender el motor.";
        }
        //si el motor esta apagado
            engine_running = true; // motor encendido
            current_charge -= 0.1; // Consumo al encender
            return String.format("üî• MOTOR ENCENDIDO\n%s %s listo para conducir\n" +
                            "Combustible: %.1f%%",
                    getBrand(), getModel(),
                    (current_charge / battery_capacity) * 100);

    }


    // M√©todo para apagar el motor
    public String stopEngine() {
        //si el motor esta encendido
        if (engine_running) {
            engine_running = false; // motor apagado
            return String.format("üõë Motor apagado\n%s %s en reposo\n" +
                            "Kil√≥metros recorridos en esta sesi√≥n: %.1f km",
                    getBrand(), getModel(), kilometers_driven);
        }
        return "‚ö†Ô∏è El motor ya est√° apagado";
    }


    // metodo para carga r√°pida
    public String startFastCharging() {
        //si la carga actual es mayor o igual a la capacidad de la bater√≠a
        if (current_charge >= battery_capacity * 0.9) {
            return "‚ö†Ô∏è Bater√≠a casi llena. Carga lenta recomendada";
        }

        charging = true; // cargando

        double charge_added = Math.min(charging_speed * 10, battery_capacity - current_charge); // carga agregada
        current_charge += charge_added;//carga actual se le acumula la carga agregada
        battery_temperature = Math.min(45, battery_temperature + 5); // aumento de temperatura de la bater√≠a

        return String.format("‚ö° CARGA R√ÅPIDA ACTIVA\n" +
                        "Energ√≠a agregada: %.2f kWh\n" +
                        "Carga actual: %.1f%% (%.1f kWh)\n" +
                        "Temperatura bater√≠a: %d¬∞C\n" +
                        "Tiempo estimado para carga completa: %.0f min",
                charge_added, (current_charge / battery_capacity) * 100,
                current_charge, battery_temperature,
                (battery_capacity - current_charge) / charging_speed);
    }

    // M√©todo para Conducir el veh√≠culo en la cual es una interfaz implementada
    @Override
    public String toDrive(){
        //si la carga actual es menor o igual a 0
        if (current_charge <= 0) {
            return String.format("üîã BATER√çA AGOTADA\n%s %s necesita carga urgente\n" +
                    "Active el modo de emergencia si es necesario", getBrand(), getModel());
        }

        double distance = Math.random() * 15 + 10; // 10-25 km simulados
        double energy_used = distance * energy_consumption_rate; // kWh consumidos

        // Eficiencia mejorada con preacondicionamiento
        if (preconditioning) {
            energy_used *= 0.9; // 10% m√°s eficiente
        }

        // Penalizaci√≥n por temperatura alta
        if (battery_temperature > 35) {
            energy_used *= 1.15; // 15% menos eficiente
        }

        current_charge = Math.max(0, current_charge - energy_used); // actualizar carga
        kilometers_driven += distance; // actualizar kil√≥metros
        battery_temperature = (int) Math.max(20, Math.min(40, battery_temperature + (distance / 10))); // ajustar temperatura

        String driving_mode = autopilot_active ? "ü§ñ PILOTO AUTOM√ÅTICO" : "üë§ CONDUCCI√ìN MANUAL";
        String efficiency = preconditioning ? " (Optimizado)" :
                battery_temperature > 35 ? " (Reducido)" : "";

        return String.format("‚ö° CONDUCIENDO %s %s\n" +
                        "%s\n" +
                        "Distancia recorrida: %.1f km\n" +
                        "Consumo: %.2f kWh%s\n" +
                        "Bater√≠a restante: %.1f%% (%.1f kWh)\n" +
                        "Temperatura: %d¬∞C\n" +
                        "Autonom√≠a restante: %.0f km",
                getBrand(), getModel(), driving_mode, distance, energy_used, efficiency,
                (current_charge / battery_capacity) * 100, current_charge,
                battery_temperature, current_charge / energy_consumption_rate);
    }

    @Override
    // metodo para acelerar el veh√≠culo
    public void accelerate() {
        //si la carga actual es mayor a 0
        if (current_charge > 0) {
            // energia usada
            double energy_used = 0.05; // kWh por aceleraci√≥n
            current_charge = Math.max(0, current_charge - energy_used);  // actualizar carga actual
            battery_temperature = Math.min(40, battery_temperature + 1); // aumentar temperatura

            String efficiency_note = battery_temperature > 35 ? " (Rendimiento reducido por temperatura)" :
                    preconditioning ? " (Rendimiento optimizado)" : ""; // nota de eficiencia

            System.out.printf("‚ö° %s %s acelerando silenciosamente\n" +
                            "Bater√≠a: %.1f%% | Temp: %d¬∞C%s\n",
                    getBrand(), getModel(),
                    (current_charge / battery_capacity) * 100,
                    battery_temperature, efficiency_note);
        } else {
            System.out.println("üîã Bater√≠a agotada. Veh√≠culo en modo seguro");
        }
    }

    // metodo para frenar el veh√≠culo
    @Override
    public void brake() {
        //si la carga actual es menor al 95% de la capacidad de la bater√≠a
        if (current_charge < battery_capacity * 0.95) {
            // Regeneraci√≥n de energ√≠a al frenar
            double energy_recovered = 0.02;
            current_charge = Math.min(battery_capacity, current_charge + energy_recovered); // actualizar carga

            System.out.printf("üîã %s %s frenando con regeneraci√≥n\n" +
                            "Energ√≠a recuperada: %.2f kWh | Bater√≠a: %.1f%%\n",
                    getBrand(), getModel(), energy_recovered,
                    (current_charge / battery_capacity) * 100);
        } else {
            System.out.printf("üõë %s %s frenando\n", getBrand(), getModel());
        }

        battery_temperature = Math.max(20, battery_temperature - 1);
    }

    // m√©todo para asistencia en emergencias
    @Override
    public String emergencyAssistance() {
        emergency_mode = true; // activar modo emergencia
        autopilot_active = false; // desactivar piloto autom√°tico

        // Reservar energ√≠a para funciones de emergencia
        double emergency_reserve = battery_capacity * 0.05;
        // si la carga actual es menor a la reserva de emergencia
        if (current_charge < emergency_reserve) {
            // usar toda la carga disponible
            current_charge = emergency_reserve;
        }

        return String.format("üö® SISTEMA DE EMERGENCIA ACTIVADO üö®\n" +
                        "Veh√≠culo: %s %s\n" +
                        "‚úÖ Frenado autom√°tico de emergencia\n" +
                        "‚úÖ Llamada autom√°tica a servicios (911)\n" +
                        "‚úÖ Activaci√≥n de luces de emergencia\n" +
                        "‚úÖ GPS enviado a contactos de emergencia\n" +
                        "‚úÖ C√°maras grabando incidente\n" +
                        "‚úÖ Climatizaci√≥n de emergencia activa\n" +
                        "üîã Reserva de energ√≠a: %.1f%% disponible\n" +
                        "üìç Ubicaci√≥n transmitida cada 30 segundos",
                getBrand(), getModel(),
                (current_charge / battery_capacity) * 100);

    }

    // metodo para desactivar el modo emergencia
    public String deactivate_emergency() {
        if (!emergency_mode) {
            return "‚ö†Ô∏è Modo emergencia no est√° activo";
        }

        //modo emergencia desactivado
        emergency_mode = false;
        return String.format("‚úÖ EMERGENCIA DESACTIVADA\n" +
                "%s %s volviendo a modo normal\n" +
                "Sistemas restaurados correctamente", getBrand(), getModel());
    }

    // m√©todo para activar/desactivar el piloto autom√°tico
    @Override
    public String autoPilot() {
        //si la carga actual es menor al 20% de la capacidad de la bater√≠a
        if (current_charge < battery_capacity * 0.20) {
            return "‚ö†Ô∏è Bater√≠a insuficiente para piloto autom√°tico (m√≠nimo 20%)";
        }

        if (emergency_mode) {
            return "‚ùå Piloto autom√°tico no disponible en modo emergencia";
        }

        autopilot_active = !autopilot_active; // asignar el valor contrario

            // si el piloto autom√°tico est√° activo
        if (autopilot_active) {
            preconditioning = true; // activar preacondicionamiento
            return String.format("ü§ñ PILOTO AUTOM√ÅTICO ACTIVADO\n" +
                            "Veh√≠culo: %s %s\n" +
                            "‚úÖ Conducci√≥n aut√≥noma nivel 4\n" +
                            "‚úÖ Monitoreo 360¬∞ activo\n" +
                            "‚úÖ IA predictiva funcionando\n" +
                            "‚úÖ Sistemas de seguridad en m√°xima alerta\n" +
                            "üîã Consumo optimizado autom√°ticamente\n" +
                            "üì° Conectado a red de veh√≠culos inteligentes",
                    getBrand(), getModel());
        } else {
            return String.format("üë§ Control manual restaurado en %s %s\n" +
                    "Piloto autom√°tico desactivado", getBrand(), getModel());
        }
    }
 //  m√©todo para mostrar la informaci√≥n general del veh√≠culo
    @Override
    public VehicleInfo display_general_information() {
        // estado del modo si est√° en emergencia, piloto autom√°tico o manual
        String mode_status = emergency_mode ? "üö® EMERGENCIA" :
                autopilot_active ? "ü§ñ Piloto Autom√°tico" : "üë§ Manual";
        // estado de la salud de la bater√≠a si est√° caliente, optimizada o normal
        String battery_health = battery_temperature > 35 ? "‚ö†Ô∏è Caliente" :
                preconditioning ? "‚úÖ Optimizada" : "üå°Ô∏è Normal";

        String specificInfo = String.format(
                "‚ö° INFORMACI√ìN T√âCNICA:\n" +
                        "Capacidad Bater√≠a: %.1f kWh\n" +
                        "Carga Actual: %.1f kWh (%.1f%%)\n" +
                        "Consumo Promedio: %.2f kWh/100km\n" +
                        "Autonom√≠a Restante: %.0f km\n" +
                        "Temperatura Bater√≠a: %d¬∞C (%s)\n" +
                        "Modo Actual: %s\n" +
                        "Kil√≥metros Totales: %.1f km\n" +
                        "Estado Carga: %s",
                battery_capacity, current_charge, (current_charge / battery_capacity) * 100,
                energy_consumption_rate * 100, current_charge / energy_consumption_rate,
                battery_temperature, battery_health, mode_status, kilometers_driven,
                charging ? "üîå Cargando" : "üîã Listo");

        return new VehicleInfo(getId(), getBrand(), getModel(), getYear(), getMaximum_speed(),
                "Veh√≠culo El√©ctrico", specificInfo,
                "Conducible + Piloto Autom√°tico + Asistencia Emergencias");
    }

    // Getters y Setters
    public double getBattery_capacity() { return battery_capacity; }
    public void setBattery_capacity(double battery_capacity) { this.battery_capacity = battery_capacity; }
    public double getCurrent_charge() { return current_charge; }
    public void setCurrent_charge(double current_charge) {
        this.current_charge = Math.max(0, Math.min(battery_capacity, current_charge));
    }
    public boolean isEmergency_mode() { return emergency_mode; }
    public boolean isAutopilot_active() { return autopilot_active; }
    public int getBattery_temperature() { return battery_temperature; }
    public double getKilometers_driven() { return kilometers_driven; }
    public boolean isCharging() { return charging; }
    public boolean isEngine_running() { return engine_running; }
    public double getBattery_percentage() { return (current_charge / battery_capacity) * 100; }
    public double getRange() { return current_charge / energy_consumption_rate; }
    public boolean isPreconditioning() { return preconditioning; }
}